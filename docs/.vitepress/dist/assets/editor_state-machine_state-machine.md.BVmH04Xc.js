import{_ as s,C as o,c as n,o as i,j as e,G as r,ag as c,a as p}from"./chunks/framework.WXS6e2PS.js";const d="/docs/images/editor/state-machine/307461c0-2006-4fdf-bdc3-61875d40f422.webp",m="/docs/images/editor/state-machine/state-machine-overview-inputs.gif",I=JSON.parse('{"title":"状态机概览 (State Machine Overview)","description":"为您动画注入智慧。","frontmatter":{"title":"状态机概览 (State Machine Overview)","description":"为您动画注入智慧。"},"headers":[],"relativePath":"editor/state-machine/state-machine.md","filePath":"editor/state-machine/state-machine.md"}'),u={name:"editor/state-machine/state-machine.md"};function l(h,t,f,g,v,b){const a=o("YouTube");return i(),n("div",null,[t[0]||(t[0]=e("h2",{id:"概览-overview",tabindex:"-1"},[p("概览 (Overview) "),e("a",{class:"header-anchor",href:"#概览-overview","aria-label":'Permalink to "概览 (Overview)"'},"​")],-1)),t[1]||(t[1]=e("p",null,"状态机是一种可视化的方式，用于将动画连接在一起并定义驱动过渡（Transitions）的逻辑。它们允许您构建交互式的动效图形，并可以随时实现在您的产品、应用、游戏或网站中。",-1)),t[2]||(t[2]=e("p",null,"状态机为设计师和开发者之间建立了一个全新的协作层面，允许双方在开发过程中进行深度迭代，而无需复杂的交接过程。",-1)),r(a,{videoId:"0Hb7SlEW6MI"}),t[3]||(t[3]=c('<p>使用状态机需要设计师和动画师以更接近开发者的方式去思考问题，但这种方式是直接且可视化的。</p><p>默认情况下，每个画板至少有一个状态机，但您可以根据需要创建任意多个。要创建新状态机，请点击动画列表（Animations List）中的加号按钮并选择 &quot;State Machine&quot; 选项。</p><h3 id="状态机的组成-anatomy-of-a-state-machine" tabindex="-1">状态机的组成 (Anatomy of a State Machine) <a class="header-anchor" href="#状态机的组成-anatomy-of-a-state-machine" aria-label="Permalink to &quot;状态机的组成 (Anatomy of a State Machine)&quot;">​</a></h3><p>一个基础的状态机包含图表（Graph）、<a href="/docs/editor/state-machine/states">状态 (States)</a>、<a href="/docs/editor/state-machine/transitions">过渡 (Transitions)</a>、<a href="/docs/editor/state-machine/inputs">输入 (Inputs)</a> 和 <a href="/docs/editor/state-machine/layers">图层 (Layers)</a>。我们将在此章节中深入探讨这些组成要素及更多内容。</p><p><strong>图表 (Graph)</strong> 是您添加状态和连接过渡的控件空间。当在动画列表中选中一个状态机时，它会替代时间轴出现。</p><p><img src="'+d+'" alt="State Machine Graph"></p><p><strong>状态 (States)</strong> 本质上就是可以在状态机中播放的时间轴动画。通常，它们代表了动画内容的某种特定状态。例如，一个按钮通常会有 &quot;Idle&quot;（空闲，按钮静止）、&quot;Hovered&quot;（悬停，鼠标滑过时的样子）和 &quot;Clicked&quot;（点击，被点击时的样子）这些状态。</p><p><img src="https://ucarecdn.com/ca93f148-a38c-4eac-a166-8399065315c2/" alt="Preview of States"></p><p>一旦定义了内容的各个状态，我们就可以用过渡将它们联系起来，为状态机在这些不同时间轴之间建立一条逻辑路径。我们正在为状态机从一个动画跳转到下一个动画创建一张地图。</p><p><img src="https://ucarecdn.com/cf0f53e3-abc9-43a9-b43a-e18483fe2613/" alt="Creating Transitions"></p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><strong>弃用通知：</strong> 此部分涉及旧版的输入系统（Inputs system）。<br><strong>对于新项目：</strong> 请改用 <a href="/docs/editor/data-binding">数据绑定 (Data Binding)</a>。<br><strong>对于现有项目：</strong> 请计划尽快从 Inputs 迁移到 Data Binding。<br><strong>提供此内容仅用于支持旧版。</strong></p></div><p>&quot;输入&quot;（Inputs）是用于在状态机中控制过渡的旧版工具。虽然目前仍可以使用 Inputs 来控制过渡，但&quot;数据绑定&quot;被认为是最佳实践，因为视图模型（View Models）在运行时功能更强大且更易于控制。</p><p>Inputs 的最佳用途是进行快速、原型的交互设计，且不打算将其迁移到生产环境运行时。</p><p>Inputs 是设计师与开发者之间的契约。作为设计师，我们将其作为过渡发生的规则。例如，我们可以有一个名为 <code>isHovered</code> 的布尔值，该布尔值控制着空闲状态与悬停状态之间的过渡：当布尔值为 true 时，状态机进入悬停状态；当为 false 时，回到空闲状态。开发者在运行时接入这些输入，并定义控制状态机输入的各种动作（例如定义可以改变 <code>isHovered</code> 布尔值的命中区域）。</p><p><img src="'+m+'" alt="Adding Inputs and Conditions"></p><p>最后，所有状态机都至少有一个<strong>图层 (Layer)</strong>。由于给定的图层一次只能播放一个动画，因此如果我们想要混合不同的动画或添加额外的交互，就可以添加多个图层。例如，下图中这个状态机就有多个图层，每个图层都包含控制该菜单中其中一个按钮的逻辑。</p><p><img src="https://ucarecdn.com/9b454ffc-1e08-495c-a4b7-b6ba71a7cbd2/" alt="Image"></p>',17))])}const S=s(u,[["render",l]]);export{I as __pageData,S as default};
