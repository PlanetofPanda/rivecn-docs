import{_ as e,c as i,o as t,ag as o}from"./chunks/framework.WXS6e2PS.js";const r="/docs/images/getting-started/best-practices/breaking-up-raster-images.webp",b=JSON.parse('{"title":"最佳实践","description":"编辑器和运行时性能及使用注意事项。","frontmatter":{"title":"最佳实践","description":"编辑器和运行时性能及使用注意事项。"},"headers":[],"relativePath":"getting-started/best-practices.md","filePath":"getting-started/best-practices.md"}'),l={name:"getting-started/best-practices.md"};function s(h,a,p,d,c,n){return t(),i("div",null,[...a[0]||(a[0]=[o('<p>Rive 专为在编辑器中以及在应用和游戏的运行时高效播放交互图形而构建。然而，优化不当的动画可能会消耗大量资源并导致性能不佳，尤其是在低端设备上。在以下部分中，我们将概述在 Rive 编辑器中设计/动画制作期间以及在应用程序运行时保持最佳性能和最小资源利用的重要注意事项和技巧。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>我们建议在目标设备/平台上持续测试您的动画。</p></div><h2 id="设计时注意事项" tabindex="-1">设计时注意事项 <a class="header-anchor" href="#设计时注意事项" aria-label="Permalink to &quot;设计时注意事项&quot;">​</a></h2><p>以下是在 Rive 编辑器中保持 Rive 高性能的一些技巧：</p><h3 id="资源优化" tabindex="-1">资源优化 <a class="header-anchor" href="#资源优化" aria-label="Permalink to &quot;资源优化&quot;">​</a></h3><p>图像、音频和字体资源通常是 .riv 文件膨胀的最大来源。未优化的资源会增加下载大小，并且必须加载到内存中，这可能会导致速度变慢——尤其是在低端设备上。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>只有在画板中使用的资源才会为运行时编译。资源面板中未在画板中使用的项目不会增加 .riv 文件的大小。</p></div><h4 id="字体" tabindex="-1">字体 <a class="header-anchor" href="#字体" aria-label="Permalink to &quot;字体&quot;">​</a></h4><p>字体文件通常包含数千个您可能不需要的字形，例如希腊字母、数学运算符和图标。要减小导出的字体或 .riv 文件的大小，请<a href="/docs/editor/text/fonts#glyph-%2F-script-selection">选择要包含的字形</a>。</p><h4 id="光栅图像尺寸和维度" tabindex="-1">光栅图像尺寸和维度 <a class="header-anchor" href="#光栅图像尺寸和维度" aria-label="Permalink to &quot;光栅图像尺寸和维度&quot;">​</a></h4><p>确保图像资源的大小适合其用途至关重要。例如，避免在画板的小区域（例如 100 x 100）中显示时使用大尺寸的图像（例如 8192 x 7022）。</p><p>使用大图像会快速消耗设备内存。这在移动设备上尤其如此，因为应用程序的内存更受限制。即使这些图像被压缩，它们的维度仍然会影响应用程序内存的使用量。</p><p>如果您有一个非常大的图像，并且在任何给定时间只有部分可见（例如滚动背景），请考虑将图像分解为较小的块，或者混合光栅和矢量，将其中一部分重新创建为矢量。</p><p><img src="'+r+'" alt="Image"></p><h4 id="光栅图像压缩" tabindex="-1">光栅图像压缩 <a class="header-anchor" href="#光栅图像压缩" aria-label="Permalink to &quot;光栅图像压缩&quot;">​</a></h4><p>压缩涉及通过采用各种算法丢弃一些图像数据来减小文件大小。您可以直接从 Rive 编辑器压缩图像，这意味着您保留原始图像，但压缩图像以供运行时使用。如果资源嵌入在动画中，这将减小导出的 riv 的文件大小。</p><p>为获得最小的图像文件大小和最佳性能，我们建议使用 WebP 格式导出资源。</p><h4 id="矢量图像" tabindex="-1">矢量图像 <a class="header-anchor" href="#矢量图像" aria-label="Permalink to &quot;矢量图像&quot;">​</a></h4><p>在矢量图像中高效使用顶点数量。虽然几个额外的顶点不会有太大影响，但数千个可能会。在导入由 AI 生成、从光栅图像转换或在绘图应用中创建的矢量时要特别小心。</p><h3 id="导入-lottie-文件" tabindex="-1">导入 Lottie 文件 <a class="header-anchor" href="#导入-lottie-文件" aria-label="Permalink to &quot;导入 Lottie 文件&quot;">​</a></h3><p>虽然 Rive 提供了 Lottie 转换器以便轻松导出 .riv 文件，但直接在 Rive 中重新创建图形和动画通常会产生更小的文件大小。如果您要导入 Lottie 文件，可以通过将图像从 PNG 转换为 WebP 并选择仅导出字体文件的必要字形来进一步减小 .riv 文件大小。此外，您可以<a href="#out-of-band-assets">带外加载资源</a>以在多个 .riv 文件中重用字体和图像，从而优化存储。</p><p>直接在 Rive 中工作通常更可取，因为它允许根据动画要求优化文件。例如，使用骨骼和约束创建装备将比直接从 Lottie 转换产生更少的关键帧。</p><h3 id="web-的图层混合模式" tabindex="-1">Web 的图层混合模式 <a class="header-anchor" href="#web-的图层混合模式" aria-label="Permalink to &quot;Web 的图层混合模式&quot;">​</a></h3><p>混合模式在 Web 上特别昂贵，因为 WebGL 没有公开访问帧缓冲区的机制。要应用混合模式，Rive 必须在合成之前将渲染的像素复制到单独的纹理中，这会带来显著的性能和内存开销。</p><p>虽然正在通过新的 WebGL 功能来改进此问题，但这些解决方案仍在等待更广泛的支持。在此之前，最好在 Web 项目中谨慎使用混合模式以确保最佳性能。</p><h3 id="画板注意事项" tabindex="-1">画板注意事项 <a class="header-anchor" href="#画板注意事项" aria-label="Permalink to &quot;画板注意事项&quot;">​</a></h3><h4 id="裁剪画板" tabindex="-1">裁剪画板 <a class="header-anchor" href="#裁剪画板" aria-label="Permalink to &quot;裁剪画板&quot;">​</a></h4><p>裁剪画板通常没有问题，但如果您遇到性能问题，值得尽量减少它们的使用。裁剪可能在计算上很昂贵，因为渲染器必须评估每个对象（包括组件实例）以确定像素可见性。相反，请考虑将裁剪应用于画板内的特定对象或组 within the artboard。</p><p>在大多数情况下，您可以安全地从主画板本身删除裁剪，因为在运行时不会渲染 Rive 实例之外的任何内容。</p><h4 id="未使用的画板" tabindex="-1">未使用的画板 <a class="header-anchor" href="#未使用的画板" aria-label="Permalink to &quot;未使用的画板&quot;">​</a></h4><p>未使用的画板仍然包含在编译的 .riv 文件中，并在首次加载文件时进行解析。这可能导致不必要的内存使用和性能开销，尤其是如果未使用的画板包含复杂的动画或大型资源。为了保持文件精简和高效，最佳实践是删除任何未主动使用的画板。</p><h3 id="空闲动画" tabindex="-1">空闲动画 <a class="header-anchor" href="#空闲动画" aria-label="Permalink to &quot;空闲动画&quot;">​</a></h3><p>如果您有空闲动画状态，其中图形在状态机中的给定状态下保持静态，请考虑使用&quot;one-shot&quot;动画并确保时间轴动画没有不必要的长度。在状态机的运行时，如果没有播放循环动画或活动的混合状态，运行时将预先&quot;暂停&quot;自身，直到状态机输入或 Rive 监听器触发状态机中的下一个转换。这很有用，因为资源消耗（即 CPU 使用率）可能会降低到使 Rive 对应用程序资源的影响可以忽略不计的程度。</p><p>场景：图标、按钮、仅根据用户交互进行动画的图形等。</p><h3 id="使用-solos" tabindex="-1">使用 Solos <a class="header-anchor" href="#使用-solos" aria-label="Permalink to &quot;使用 Solos&quot;">​</a></h3><p><a href="/docs/editor/manipulating-shapes/solos">Solo</a> 类似于组，但具有切换嵌套对象渲染的附加能力。它的功能类似于单选按钮，可停用同一级别的其他对象。</p><p>Solos 的一个常见用例是为角色创建不同的皮肤，可以轻松打开和关闭。使用 Solos 比单独为每个对象的不透明度设置动画要快得多。此外，它允许编辑器和运行时通过不计算/渲染已停用的 Solos 来优化您的动画。</p><h3 id="混合状态" tabindex="-1">混合状态 <a class="header-anchor" href="#混合状态" aria-label="Permalink to &quot;混合状态&quot;">​</a></h3><p>与&quot;空闲动画&quot;中的指导类似，确保混合状态转换到其他状态，或在完成时移至退出状态（如果可能）。当混合状态在运行时被激活时，Rive 将持续播放状态机，即使不再需要。在完成时提供一些从混合状态的转换，可确保 Rive 在考虑在播放状态机时的任何时候是否自我暂停时少跟踪一个&quot;活动&quot;动画。</p><h2 id="运行时注意事项" tabindex="-1">运行时注意事项 <a class="header-anchor" href="#运行时注意事项" aria-label="Permalink to &quot;运行时注意事项&quot;">​</a></h2><p>以下是在应用程序中使用 Rive 运行时保持 Rive 高性能的一些技巧：</p><h3 id="带外资源" tabindex="-1">带外资源 <a class="header-anchor" href="#带外资源" aria-label="Permalink to &quot;带外资源&quot;">​</a></h3><p>请参阅我们关于<a href="/docs/runtimes/loading-assets">加载资源</a>的文档。此功能允许您在运行时通过代码动态加载和替换资源（例如字体、图像和音频），并将资源提供给您的 Rive 图形。这具有以下好处：</p><ul><li>减小导出的 <code>.riv</code> 二进制文件大小。</li><li>资源可以在多个 Rive 文件或应用程序的其他区域中重用。</li><li>资源可以在显示 Rive 图形之前预加载和缓存，以便更容易获得。</li><li>资源可以根据用户的屏幕大小和分辨率进行交换，例如在此 <a href="https://codesandbox.io/p/sandbox/cool-dewdney-hlk5xl?file=%2Fsrc%2Findex.ts" target="_blank" rel="noreferrer">web JS 示例</a>中。</li></ul><h3 id="缓存您的-riv" tabindex="-1">缓存您的 .riv <a class="header-anchor" href="#缓存您的-riv" aria-label="Permalink to &quot;缓存您的 .riv&quot;">​</a></h3><p>如果您在页面或应用的多个位置使用相同的 Rive 文件，您可以<a href="/docs/runtimes/caching-a-rive-file">缓存 .riv</a> 文件以提高性能。缓存的主要好处是文件只需要解析和解码一次。从缓存的、已解码的文件创建新的画板实例比每次在实例化画板之前解码文件要快得多。</p><h3 id="编程暂停" tabindex="-1">编程暂停 <a class="header-anchor" href="#编程暂停" aria-label="Permalink to &quot;编程暂停&quot;">​</a></h3><p>在几种情况下，您可能希望以编程方式暂停使用 Rive 配置的状态机。通过在运行时暂停 Rive 图形，您可能会注意到 Rive 对应用程序的影响具有可忽略不计的资源消耗（即 CPU）。</p><ol><li><p>Rive 图形在屏幕外</p><p>a. 如果 Rive 图形滚动到屏幕外并且不需要继续播放，请在您使用的相应运行时上调用 <code>pause</code> API，以防止 Rive 在不需要时继续动画和消耗资源。</p><p>b. 当图形需要继续动画（如果返回屏幕）时，调用 <code>play</code> API 继续播放 Rive。</p></li><li><p>辅助功能</p><ul><li>如果用户在设备设置中设置了他们更喜欢减少运动，您可能希望在运行时读取此属性，并以编程方式调用 <code>pause</code> 或使用 Rive 运行时设置 <code>autoplay: false</code>，以确保这些用户在导航应用程序时减少运动。或者，可以创建不同的画板或状态机并在运行时加载，使其具有不同的功能。</li></ul></li><li><p>状态机使用静态图形处于空闲状态</p><p>a. 当 Rive 图形空闲时，在等待来自用户交互、数据解析等的状态机转换时<code>暂停</code>。</p></li></ol><h3 id="低端设备" tabindex="-1">低端设备 <a class="header-anchor" href="#低端设备" aria-label="Permalink to &quot;低端设备&quot;">​</a></h3><p>Rive 将尝试在所有浏览器/设备上高性能运行，但如果可以，请测试您的应用程序在资源受限的设备上使用特定 Rive 图形运行的性能。您可能会发现，对于给定的屏幕，包含大量动画图形的 Rive 文件对于真正需要的内容来说可能过度，并决定显示静态 Rive 图形（即 autoplay: false）或减少在任何给定时刻动画的 Rive 实体数量。</p><p>低端设备的策略可能是创建具有减少使用/运动的替代画板或状态机，可以在运行在旧设备上时在运行时动态加载。</p>',52)])])}const v=e(l,[["render",s]]);export{b as __pageData,v as default};
