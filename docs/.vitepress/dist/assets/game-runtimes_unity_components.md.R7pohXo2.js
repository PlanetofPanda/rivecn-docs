import{_ as e,c as d,o as r,ag as a}from"./chunks/framework.WXS6e2PS.js";const p=JSON.parse('{"title":"组件 (Components)","description":"","frontmatter":{"title":"组件 (Components)","description":""},"headers":[],"relativePath":"game-runtimes/unity/components.md","filePath":"game-runtimes/unity/components.md"}'),i={name:"game-runtimes/unity/components.md"};function o(n,t,l,s,h,c){return r(),d("div",null,[...t[0]||(t[0]=[a('<p>Rive Unity 软件包包含了一些组件，旨在帮助您快速、轻松地将 Rive 集成到项目中。这些组件是对<a href="/docs/game-runtimes/unity/fundamentals">低级 API</a> 的高级抽象，负责处理渲染和指针输入，并在不同渲染管线之间为 Rive 提供统一的使用方式。</p><p>我们建议大多数情况下使用这些组件，除非您有特定的渲染需求，或是需要对 Rive 在图形管线中的位置进行更精细的控制，在这种情况下您可以使用低级 API。</p><h2 id="rive-面板-rive-panel" tabindex="-1">Rive 面板 (Rive Panel) <a class="header-anchor" href="#rive-面板-rive-panel" aria-label="Permalink to &quot;Rive 面板 (Rive Panel)&quot;">​</a></h2><p>Rive 面板（Rive Panel）是在 Unity 中显示 Rive 图形的基础。它作为一个视口（viewport），负责管理一组 Rive 挂件（Widgets）并将其渲染到渲染纹理（Render Texture）上，面板的尺寸决定了渲染目标的大小。</p><p>该面板可以将多个挂件渲染到单个渲染纹理中，这意味着您可以通过在同一个面板下放置多个 Rive 挂件，将不同的 Rive 文件和画板绘制到同一张纹理上。这比使用多个面板性能更好，因为默认情况下每个面板都会渲染到独立的纹理。</p><h4 id="设置-setup" tabindex="-1">设置 (Setup) <a class="header-anchor" href="#设置-setup" aria-label="Permalink to &quot;设置 (Setup)&quot;">​</a></h4><p>创建一个实例：在场景层级点击右键 <code>→ Rive → Rive Panel</code>。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Rive 面板仅负责将图形绘制到纹理。您需要将 Rive 面板<strong>配合</strong>一个<a href="/docs/game-runtimes/unity/components#panel-renderers">面板渲染器 (Panel Renderer)</a> 使用，才能在屏幕上显示纹理。</p></div><p><strong>配置项</strong></p><table tabindex="0"><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Custom Render Target Strategy</td><td>用于渲染面板的策略。默认情况下，每个面板渲染到与其尺寸匹配的单个 RenderTexture。您可以提供不同的策略，例如渲染到纹理池或在面板间共享纹理。</td></tr><tr><td>Update Mode</td><td>控制面板如何更新挂件：<code>Auto</code> 为每帧自动更新，<code>Manual</code> 则需要通过调用 <code>Tick()</code> 进行显式控制。</td></tr><tr><td>Disable Editor Preview</td><td>使用此选项防止面板在 Unity 编辑器的编辑模式（Edit mode）下进行渲染。</td></tr></tbody></table><p><strong>属性</strong></p><table tabindex="0"><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Widget Container</td><td>持有面板下挂件的 RectTransform。</td></tr><tr><td>Widgets</td><td>由该面板管理的挂件只读列表。</td></tr><tr><td>Render Texture</td><td>当前绘制挂件的渲染纹理。</td></tr><tr><td>Scale In RenderTexture</td><td>面板在其渲染纹理中的缩放比例。如果未设置渲染策略，返回 <code>Vector2.one</code>。</td></tr><tr><td>Offset In Render Texture</td><td>面板在其渲染纹理中的偏移量。如果未设置渲染目标策略，返回 <code>Vector2.one</code>。</td></tr><tr><td>Is Rendering</td><td>描述面板是否当前已注册到渲染目标策略并正在活跃地渲染。</td></tr></tbody></table><p><strong>公共方法</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Tick(float deltaTime)</td><td>更新面板中的所有挂件。在 Auto 模式下自动调用。<br>仅当 <code>Update Mode</code> 设置为 <code>Manual</code> 时才需要手动调用此方法。</td></tr><tr><td>StartRendering()</td><td>如果面板尚未渲染到渲染纹理，则开始渲染。</td></tr><tr><td>StopRendering()</td><td>如果面板正在渲染到渲染纹理，则停止渲染。</td></tr><tr><td>SetDimensions(Vector2 dimensions)</td><td>设置面板的宽度和高度。</td></tr><tr><td>RegisterInputProvider(IPanelInputProvider provider)</td><td>注册一个自定义输入提供者，用于处理指针事件。</td></tr><tr><td>UnregisterInputProvider(IPanelInputProvider provider)</td><td>移除之前注册的输入提供者。</td></tr></tbody></table><h2 id="rive-挂件-rive-widget" tabindex="-1">Rive 挂件 (Rive Widget) <a class="header-anchor" href="#rive-挂件-rive-widget" aria-label="Permalink to &quot;Rive 挂件 (Rive Widget)&quot;">​</a></h2><p>Rive 挂件（Rive Widget）是在 Unity 中显示 Rive 画板的主要组件。它负责加载 Rive 文件，既可以是在编辑时从资产（Assets）加载，也可以是在运行时加载的文件（适用于从服务器或 Addressables 加载内容）。该组件管理画板和状态机的设置，自动配置显示图形所需的一切。</p><h4 id="设置-setup-1" tabindex="-1">设置 (Setup) <a class="header-anchor" href="#设置-setup-1" aria-label="Permalink to &quot;设置 (Setup)&quot;">​</a></h4><p>创建一个实例：在场景层级点击右键 <code>→ Rive → Widgets → RiveWidget</code>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Rive 挂件必须放置在 RivePanel 下才能被显示。</p></div><p><strong>配置项</strong></p><table tabindex="0"><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Asset</td><td>要加载的 Rive 资产 (.riv)。</td></tr><tr><td>Artboard Name</td><td>从 Rive 文件中加载的画板名称。</td></tr><tr><td>State Machine Name</td><td>从所选画板中加载的状态机名称。</td></tr><tr><td>Hit Test Behaviour</td><td>指针事件的处理方式（Opaque, Translucent, Transparent, None）。</td></tr><tr><td>Fit</td><td>画板在其挂件边界内的适配模式。详见 <a href="/docs/runtimes/layout#fit">适配文档</a>。</td></tr><tr><td>Alignment</td><td>画板在挂件边界内的对齐方式。</td></tr><tr><td>Layout Scale Factor</td><td>使用 Layout 适配模式时的缩放乘数。</td></tr><tr><td>Layout Scaling Mode</td><td>挂件在 Layout 模式下的缩放模式（<code>ReferenceArtboardSize</code>, <code>ConstantPhysicalSize</code> 和 <code>ConstantPixelSize</code>）。</td></tr><tr><td>Fallback DPI</td><td>当屏幕 DPI 不可用时使用的备用 DPI 值。</td></tr><tr><td>Reference DPI</td><td>用于缩放计算的目标参考 DPI 值。</td></tr></tbody></table><p><strong>属性</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>File</td><td>当前加载的 Rive 文件实例。</td></tr><tr><td>Artboard</td><td>当前加载的画板实例。</td></tr><tr><td>State Machine</td><td>当前加载的状态机实例。</td></tr><tr><td>Status</td><td>挂件当前的状态（Uninitialized, Loading, Loaded, Error）。</td></tr><tr><td>BindingMode</td><td>决定挂件如何处理与 ViewModel 实例的绑定：Auto Bind Default（自动绑定默认）、Auto Bind Selected（自动绑定选定）或 Manual（手动）。</td></tr><tr><td>ViewModelInstanceName</td><td>当 BindingMode 设置为自动绑定选定时，要绑定的 ViewModel 实例名称。</td></tr></tbody></table><p><strong>事件</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OnRiveEventReported</td><td>当 Rive 图形报告 Rive 事件时触发。</td></tr><tr><td>OnWidgetStatusChanged</td><td>当挂件状态改变时触发（例如从 Loading 变为 Loaded 或 Error）。</td></tr></tbody></table><p><strong>公共方法</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Load(File file)</td><td>使用默认画板和状态机加载一个 Rive 文件。</td></tr><tr><td>Load(File file, string artboardName, string stateMachineName)</td><td>指定画板和状态机加载一个 Rive 文件。</td></tr><tr><td>Load(Asset asset)</td><td>使用资产加载，使用默认画板和状态机。Rive Widget 会管理加载文件的生命周期，并在组件销毁或新资产传入时进行清理。</td></tr><tr><td>Load(Asset asset, string artboardName, string stateMachineName)</td><td>指定画板和状态机从资产加载。Rive Widget 负责管理底层文件的生命周期。</td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果您使用了任何接受 <code>File</code> 实例的 Load 方法，您需要负责在不再需要时手动销毁（dispose）该 File 实例。而从 <code>Asset</code> 加载时则无需担心，因为 Rive Widget 会自动管理底层文件（加载和销毁）。</p></div><h2 id="过程化-rive-挂件-procedural-rive-widget" tabindex="-1">过程化 Rive 挂件 (Procedural Rive Widget) <a class="header-anchor" href="#过程化-rive-挂件-procedural-rive-widget" aria-label="Permalink to &quot;过程化 Rive 挂件 (Procedural Rive Widget)&quot;">​</a></h2><p>过程化 Rive 挂件（Procedural Rive Widget）支持使用 Rive 渲染器在运行时生成图形。此组件允许您通过编程方式，使用 Rive 的绘图原语（路径、填充等）来创建图形。 可以参考<a href="https://github.com/rive-app/rive-unity/blob/0765c81e1b68e77fcbf0e62afee7290eff400d17/tests/package/PlayModeTests/Components/Goldens/TestPanels/TestProceduralDrawing.cs" target="_blank" rel="noreferrer">此示例</a>了解过程化绘图的实际实现。</p><h4 id="设置-setup-2" tabindex="-1">设置 (Setup) <a class="header-anchor" href="#设置-setup-2" aria-label="Permalink to &quot;设置 (Setup)&quot;">​</a></h4><p>创建一个实例：在场景层级点击右键 <code>→ Rive → Widgets → Procedural Rive Widget</code>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>过程化 Rive 挂件必须放置在 RivePanel 下才能被显示。</p></div><p><strong>配置项</strong></p><table tabindex="0"><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Procedural Drawing</td><td>定义绘图内容的 ProceduralDrawing 实例。</td></tr><tr><td>Hit Test Behavior</td><td>指针事件的处理方式（Opaque, Translucent, Transparent, None）。</td></tr></tbody></table><p><strong>属性</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Status</td><td>挂件当前的状态（Uninitialized, Loading, Loaded, Error）。</td></tr></tbody></table><p><strong>事件</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OnWidgetStatusChanged</td><td>当挂件状态改变时触发。</td></tr></tbody></table><p><strong>公共方法</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Load(ProceduralDrawing proceduralDrawing)</td><td>向挂件加载一个新的过程化绘图实例。</td></tr></tbody></table><h2 id="面板渲染器-panel-renderers" tabindex="-1">面板渲染器 (Panel Renderers) <a class="header-anchor" href="#面板渲染器-panel-renderers" aria-label="Permalink to &quot;面板渲染器 (Panel Renderers)&quot;">​</a></h2><p>面板渲染器将 RivePanel 的渲染纹理连接到 Unity 的显示系统。通过将渲染逻辑与显示层面解耦，我们可以在保持核心 Rive 功能一致的同时，支持不同的渲染上下文（UI、世界空间等）。</p><p>每种渲染器类型都专门针对特定的 Unity 渲染路径，自动处理输入系统和渲染顺序等细节。</p><h3 id="rive-画布渲染器-rive-canvas-renderer" tabindex="-1">Rive 画布渲染器 (Rive Canvas Renderer) <a class="header-anchor" href="#rive-画布渲染器-rive-canvas-renderer" aria-label="Permalink to &quot;Rive 画布渲染器 (Rive Canvas Renderer)&quot;">​</a></h3><p>Rive 画布渲染器在 Unity UI 系统（uGUI）中显示 Rive 内容。它会自动配置必要的 Canvas 组件，并处理 UI 相关的特定问题，如正确的渲染顺序和射线检测（raycasting）。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Rive 画布渲染器会根据其所在的 uGUI Canvas 来控制 Rive 面板的大小。</p></div><p>您也可以通过在场景层级点击右键并导航到 <code>Rive &gt; Rive Panel (Canvas)</code> 来创建一个已自动配置此组件的 Rive 面板。</p><h4 id="要求" tabindex="-1">要求 <a class="header-anchor" href="#要求" aria-label="Permalink to &quot;要求&quot;">​</a></h4><ul><li>场景中需要有 EventSystem 以处理指针输入。</li><li>Canvas 上需要有 GraphicRaycaster 以处理指针输入。</li><li>Rive 面板必须位于 uGUI canvas 之下。</li><li>此组件必须与 Rive 面板放置在同一个游戏对象（GameObject）上。</li></ul><h4 id="配置项" tabindex="-1">配置项 <a class="header-anchor" href="#配置项" aria-label="Permalink to &quot;配置项&quot;">​</a></h4><table tabindex="0"><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Pointer Input Mode</td><td>控制渲染器是否接受指针输入（启用/禁用）。</td></tr><tr><td>Custom Material</td><td>渲染 Rive 图形时使用的自定义 UI 材质。</td></tr><tr><td>Match Canvas Resolution</td><td>是否将画布分辨率与 RivePanel 分辨率匹配。当使用 <code>Canvas Scaler</code> 时，这对于保持 Rive 图形清晰非常有用。默认情况下，RivePanel 的分辨率由其 rect transform 的宽高决定。开启此项后，如果需要，RivePanel 的渲染分辨率将高于其 rect transform 的大小。目前仅在 RivePanel 使用 <code>SimpleRenderTargetStrategy</code>（默认策略）时支持此功能。</td></tr></tbody></table><h4 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h4><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Rive Panel</td><td>正在被渲染的面板。</td></tr></tbody></table><h3 id="rive-纹理渲染器-rive-texture-renderer" tabindex="-1">Rive 纹理渲染器 (Rive Texture Renderer) <a class="header-anchor" href="#rive-纹理渲染器-rive-texture-renderer" aria-label="Permalink to &quot;Rive 纹理渲染器 (Rive Texture Renderer)&quot;">​</a></h3><p>Rive 纹理渲染器将 Rive 内容投影到 3D 场景中的材质。它在 Rive 的 2D 渲染系统与 Unity 的 3D 材质系统之间架起桥梁，让您可以轻松地将 Rive 内容应用到场景中的任何网格（mesh）上。</p><h4 id="要求-1" tabindex="-1">要求 <a class="header-anchor" href="#要求-1" aria-label="Permalink to &quot;要求&quot;">​</a></h4><ul><li>必须放置在带有 MeshRenderer 的游戏对象上。例如：Cube, Plane, Quad 或 Capsule。</li><li>场景中需要有 EventSystem 以处理指针输入。</li><li>相机上需要有 PhysicsRaycaster 以处理 3D 空间中的指针输入。</li><li>目标游戏对象需要有 MeshCollider 以处理指针输入。</li></ul><h4 id="配置项-1" tabindex="-1">配置项 <a class="header-anchor" href="#配置项-1" aria-label="Permalink to &quot;配置项&quot;">​</a></h4><table tabindex="0"><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Renderer</td><td>负责显示 Rive 内容的 Unity 渲染器组件（例如 MeshRenderer）。</td></tr><tr><td>Material Texture Assignment Mode</td><td>控制将 Rive 面板的渲染纹理设置到哪些材质属性：MainTexture 设置材质的 <code>_MainTex</code> 属性；<code>TextureProperties</code> 选项允许您选择多个特定的纹理属性。</td></tr><tr><td>Visibility Optimization</td><td>决定当网格对相机不可见时，RivePanel 是否应停止渲染。</td></tr><tr><td>Pointer Input Mode</td><td>控制渲染器是否接受指针输入（启用/禁用）。</td></tr></tbody></table><h4 id="属性-1" tabindex="-1">属性 <a class="header-anchor" href="#属性-1" aria-label="Permalink to &quot;属性&quot;">​</a></h4><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Rive Panel</td><td>正在渲染到材质的面板。</td></tr></tbody></table><p><strong>公共方法</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SetPanel(IRivePanel panel)</td><td>分配一个新面板进行渲染。</td></tr><tr><td>RefreshMaterials()</td><td>在材质更改后更新材质引用。</td></tr></tbody></table><h2 id="渲染目标策略-render-target-strategies" tabindex="-1">渲染目标策略 (Render Target Strategies) <a class="header-anchor" href="#渲染目标策略-render-target-strategies" aria-label="Permalink to &quot;渲染目标策略 (Render Target Strategies)&quot;">​</a></h2><p>渲染目标策略控制 <strong>Rive 面板</strong> 如何渲染到纹理。它们决定面板是拥有独立的纹理还是共享同一个纹理图集，并处理纹理创建、面板排列和内存管理等细节。</p><h3 id="简单渲染目标策略-simple-render-target-strategy" tabindex="-1">简单渲染目标策略 (Simple Render Target Strategy) <a class="header-anchor" href="#简单渲染目标策略-simple-render-target-strategy" aria-label="Permalink to &quot;简单渲染目标策略 (Simple Render Target Strategy)&quot;">​</a></h3><p><code>Simple Render Target Strategy</code> 是 <strong>Rive 面板</strong> 的默认渲染方式，它为每个面板创建一个专用的渲染纹理。如果未提供自定义策略，它会自动添加到 Rive 面板中。</p><p>这种面板与纹理之间一对一的映射提供了非常直接的内存管理方式。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>该组件必须与它的 RivePanel 附加在同一个游戏对象上。</p></div><p><strong>配置项</strong></p><table tabindex="0"><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Panel</td><td>此策略管理的 RivePanel（在同一个游戏对象上时会自动设置）。</td></tr><tr><td>Draw Timing</td><td>渲染发生的时机：<code>Batched</code>（每帧一次）或 <code>Immediate</code>（立即更新）。</td></tr></tbody></table><p><strong>属性</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>DrawTiming</td><td>当前的绘制时机模式。</td></tr></tbody></table><h3 id="图集渲染目标策略-atlas-render-target-strategy" tabindex="-1">图集渲染目标策略 (Atlas Render Target Strategy) <a class="header-anchor" href="#图集渲染目标策略-atlas-render-target-strategy" aria-label="Permalink to &quot;图集渲染目标策略 (Atlas Render Target Strategy)&quot;">​</a></h3><p>图集渲染目标策略（Atlas Render Target Strategy）支持多个面板共享单个纹理图集（texture atlas），以优化内存使用和减少绘制调用（draw calls）。</p><p>默认情况下，它使用简单的货架包装（shelf-packing）算法在图集中高效排列面板，在遵守最大尺寸限制的前提下根据需要自动扩大纹理。</p><h4 id="设置-setup-3" tabindex="-1">设置 (Setup) <a class="header-anchor" href="#设置-setup-3" aria-label="Permalink to &quot;设置 (Setup)&quot;">​</a></h4><ol><li>创建一个实例：在场景层级点击右键 <code>→ Rive → Render Target Strategies → Atlas Render Target Strategy</code>。</li><li>分配给面板：将该策略拖入目标面板上的 <code>Custom Render Target Strategy</code> 字段。</li><li>（可选）配置图集参数，如初始大小和分辨率限制。</li></ol><h4 id="备注" tabindex="-1">备注 <a class="header-anchor" href="#备注" aria-label="Permalink to &quot;备注&quot;">​</a></h4><ul><li>共享同一策略实例的面板将共用同一个图集纹理。</li><li>创建多个策略实例可以将面板分组到不同的图集中。</li></ul><blockquote><p><a href="https://ucarecdn.com/c29cc703-05c1-49c5-ba0d-4dad985b5221" target="_blank" rel="noreferrer">观看视频</a></p></blockquote><p><strong>配置项</strong></p><table tabindex="0"><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Starting Size</td><td>图集纹理的初始尺寸（例如 1024x1024）。</td></tr><tr><td>Max Atlas Size</td><td>图集可以扩大的最大尺寸（例如 2048x2048）。</td></tr><tr><td>Max Resolution Per Panel</td><td>任何单个面板的最大分辨率。更大的面板会被等比缩小显示。</td></tr><tr><td>Padding</td><td>图集中面板之间的间距，防止纹理溢出干扰。</td></tr><tr><td>Draw Timing</td><td>渲染发生的时机：<code>Batched</code>（每帧一次）或 <code>Immediate</code>（立即更新）。</td></tr><tr><td>Custom Atlas Packing Provider</td><td>（可选）自定义包装算法（默认为货架包装）。</td></tr></tbody></table><p><strong>属性</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Packing Strategy</td><td>当前用于在图集中排列面板的策略。</td></tr><tr><td>Draw Timing</td><td>当前的绘制时机模式。</td></tr></tbody></table><p><strong>公共方法</strong></p><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Configure(Vector2Int startingSize, Vector2Int maxSize, int maxResPerPanel, int padding)</td><td>在初始化前设置图集参数。</td></tr></tbody></table><h3 id="纹理池渲染目标策略-pooled-render-target-strategy" tabindex="-1">纹理池渲染目标策略 (Pooled Render Target Strategy) <a class="header-anchor" href="#纹理池渲染目标策略-pooled-render-target-strategy" aria-label="Permalink to &quot;纹理池渲染目标策略 (Pooled Render Target Strategy)&quot;">​</a></h3><p><strong>Pooled Render Target Strategy</strong> 通过维护一个可重用的渲染纹理池来优化内存。此策略不为每个面板创建新纹理或共享单个图集，而是从管理的池中抽取纹理绘制面板，并根据需要回收。</p><p>这种方法对于具有频繁出现和消失的动态 UI 元素的场景特别有用。例如，在包含大量弹出菜单或带有 Rive 图形的工具提示的嬉戏中，该策略可以在 UI 元素显示和隐藏时重用纹理，避免不断的纹理分配和释放。</p><h4 id="配置项-2" tabindex="-1">配置项 <a class="header-anchor" href="#配置项-2" aria-label="Permalink to &quot;配置项&quot;">​</a></h4><table tabindex="0"><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>Pooled Texture Size</td><td>池中纹理的大小（所有池化纹理共享此尺寸）。如果某个 Rive 面板与纹理的宽高比不匹配，面板将被调整大小以适应纹理，并保持其宽高比。</td></tr><tr><td>Initial Pool Size</td><td>池的初始分配的大小。</td></tr><tr><td>Max Pool Size</td><td>池可以包含的最大纹理数量。</td></tr><tr><td>Pool Overflow Behavior</td><td>当池满时如何处理请求：<code>Flexible</code>（创建临时纹理）或 <code>Fixed</code>（拒绝新面板）。</td></tr><tr><td>Draw Timing</td><td>渲染发生的时机：<code>Batched</code>（每帧一次）或 <code>Immediate</code>（立即更新）。</td></tr></tbody></table><h4 id="属性-2" tabindex="-1">属性 <a class="header-anchor" href="#属性-2" aria-label="Permalink to &quot;属性&quot;">​</a></h4><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Pool Overflow</td><td>当前的溢出行为设置。</td></tr><tr><td>Pooled Texture Size</td><td>池使用的当前纹理尺寸。</td></tr><tr><td>Initial Pool Size</td><td>当前的初始池容量。</td></tr><tr><td>Max Pool Size</td><td>当前的最大池尺寸。</td></tr><tr><td>Draw Timing</td><td>当前的绘制时机模式。</td></tr></tbody></table><h4 id="公共方法" tabindex="-1">公共方法 <a class="header-anchor" href="#公共方法" aria-label="Permalink to &quot;公共方法&quot;">​</a></h4><table tabindex="0"><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>Configure(Vector2Int textureSize, int initialSize, int maxSize, PoolOverflowBehavior behavior)</td><td>设置池参数（必须在注册第一个 Rive 面板之前调用）。</td></tr></tbody></table>',97)])])}const u=e(i,[["render",o]]);export{p as __pageData,u as default};
