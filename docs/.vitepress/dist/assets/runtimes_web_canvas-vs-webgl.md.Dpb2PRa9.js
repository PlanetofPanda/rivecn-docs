import{_ as a,c as i,o as s,ag as l}from"./chunks/framework.WXS6e2PS.js";const b=JSON.parse('{"title":"Canvas vs WebGL","description":"Rive Web 运行时的包选择指南。","frontmatter":{"title":"Canvas vs WebGL","description":"Rive Web 运行时的包选择指南。"},"headers":[],"relativePath":"runtimes/web/canvas-vs-webgl.md","filePath":"runtimes/web/canvas-vs-webgl.md"}'),r={name:"runtimes/web/canvas-vs-webgl.md"};function n(p,e,c,d,o,t){return s(),i("div",null,[...e[0]||(e[0]=[l('<h3 id="背景-background" tabindex="-1">背景 (Background) <a class="header-anchor" href="#背景-background" aria-label="Permalink to &quot;背景 (Background)&quot;">​</a></h3><p>JS/WASM 运行时提供了发布到 npm 的各种包。对于简单的使用场景和更小的包体积，我们推荐从 <code>@rive-app/canvas</code> 开始（详见下文）。在 Web 上，Rive 能够关联 <code>&lt;canvas&gt;</code> 元素，并使用底层的 <code>CanvasRenderingContext2D</code> 上下文或 <code>WebGL</code> 上下文来进行渲染。</p><p><strong>注意：</strong> 对于 <code>@rive-app/webgl</code> 和 <code>@rive-app/canvas</code> 包，用于在脚本中创建 Rive 实例的高级 API 和逻辑保持一致。这意味着如果您发现某个运行时的包比另一个更适合您的用例，您只需切换依赖项即可，而无需更改代码用法。请参阅下文以了解 JS/WASM 的不同运行时包及其适用场景。</p><h3 id="推荐-rive-app-canvas" tabindex="-1">(推荐) @rive-app/canvas <a class="header-anchor" href="#推荐-rive-app-canvas" aria-label="Permalink to &quot;(推荐) @rive-app/canvas&quot;">​</a></h3><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @rive-app/canvas</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这是一个简单易用的高级 Rive API，使用底层的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">CanvasRenderingContext2D</a> 渲染器。这使得 Rive 可以利用浏览器原生的、高效的矢量图形渲染器。该包的一些优点包括：</p><ul><li>下载体积小，没有体积庞大的独立渲染器依赖。</li><li>支持 <a href="/docs/editor/text/">Rive 文本 (Rive Text)</a>。</li><li>非常适合在屏幕上并发显示多个动画画布。当您想在页面上渲染 Rive 动画列表或网格时，这是理想选择，因为浏览器对此没有上下文数量限制（而 WebGL 则有限制）。</li><li>支持基础矢量图形动画和位图。</li><li>自动为您请求 WebAssembly (WASM) 运行依赖。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>想要一个包含更少功能的 <strong>体积更小</strong> 的 Rive 依赖？考虑使用下方的 <code>@rive-app/canvas-lite</code> 👇</p></div><h3 id="rive-app-canvas-lite" tabindex="-1">@rive-app/canvas-lite <a class="header-anchor" href="#rive-app-canvas-lite" aria-label="Permalink to &quot;@rive-app/canvas-lite&quot;">​</a></h3><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @rive-app/canvas-lite</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这是一个体积比 <code>@rive-app/canvas</code> 更小的包，API 和底层的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">CanvasRenderingContext2D</a> 均相同。它为了尽可能保持体积小巧，在构建 WASM 时剔除了一些依赖项。</p><p>如果您 <strong>不需要</strong> 以下功能，此方案将是首选：</p><ul><li><a href="/docs/editor/text/">Rive 文本 (Rive Text)</a><ul><li>如果您的 Rive 文件包含 Rive 文本组件，渲染该图形时不会导致应用出错或停止渲染，但文本将不会在图形中显示。</li><li>您仍可以通过将文本外部导入为 SVG 来在图形中使用文本。</li></ul></li></ul><h3 id="rive-app-webgl" tabindex="-1">@rive-app/webgl <a class="header-anchor" href="#rive-app-webgl" aria-label="Permalink to &quot;@rive-app/webgl&quot;">​</a></h3><p>这是一个简单易用的高级 Rive API，使用 WebGL2 上下文。该包的一些优点包括：</p><ul><li>与编辑时的体验保持最高的一致性。</li><li>自动为您请求 WebAssembly (WASM) 运行依赖。</li><li>目前使用 Skia 进行渲染，但在未来的主版本发布中将被新的 Rive 渲染器取代。</li></ul><p><strong>关于 WebGL 的注意事项：</strong> 大多数浏览器对每页或每域的并发 WebGL 上下文数量有限制。在使用 Rive 时，这意味着浏览器的限制会影响创建 <code>new Rive({...})</code> 实例的数量。</p><p>如果您计划在列表/网格中或同一页面上多次显示 Rive 内容，则需要由您自行管理上下文和 <code>canvas</code> 元素的生命周期。如果您需要显示大量动画（如网格/列表），请考虑使用 <code>@rive-app/canvas</code> 包，它使用 <code>CanvasRenderingContext2D</code> 渲染器且没有上下文数量限制；或者考虑使用 <code>@rive-app/webgl-advanced</code> 包，它允许您全权控制渲染循环并在一个画布上显示多个 Rive 图形。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>建议在创建 <code>new Rive({...})</code> 对象时，在 Rive 参数中设置 <code>useOffscreenRenderer: true</code> 属性，特别是在页面上渲染多个 Rive 对象时。</p></div><h3 id="rive-app-webgl2" tabindex="-1">@rive-app/webgl2 <a class="header-anchor" href="#rive-app-webgl2" aria-label="Permalink to &quot;@rive-app/webgl2&quot;">​</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><p>这是使用 <a href="https://rive.app/renderer" target="_blank" rel="noreferrer">Rive 渲染器 (Rive Renderer)</a> 配合 WebGL2 上下文的预览版本。在未来的主版本发布中，此包可能会被弃用，届时 <code>@rive-app/webgl</code> 将完全使用 Rive 渲染器，而无需额外的 Skia 依赖。</p></div><p>这是一个简单易用的高级 Rive API，使用 WebGL2 上下文。该包的一些优点包括：</p><ul><li>与编辑时的体验保持最高的一致性。</li><li>自动为您请求 WebAssembly (WASM) 运行依赖。</li><li>使用新的 Rive 渲染器以获得最佳性能。</li><li>体积远小于目前的 <code>@rive-app/webgl</code>（后者包含体积较大的 Skia 依赖）。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>要尝试体验 Rive 渲染器的优势，您应该<a href="https://www.wikihow.tech/Enable-WebGL-Draft-Extensions-in-Google-Chrome" target="_blank" rel="noreferrer">启用 draft</a> <code>WEBGL_shader_pixel_local_storage</code> Chrome 扩展（在上方链接中添加 WebGL Draft 扩展），否则 Rive 在不支持该扩展的浏览器上将回退到 MSAA 方案（同样使用 WebGL2）。目前各大浏览器厂商正努力使其在用户的浏览器中默认支持此扩展。</p></div><p><strong>关于 WebGL 的注意事项：</strong> 大多数浏览器对每页或每域的并发 WebGL 上下文数量有限制。在使用 Rive 时，这意味着浏览器的限制会影响创建 <code>new Rive({...})</code> 实例的数量。</p><p>如果您计划在同一个页面上显示大量 Rive 内容，请考虑使用无上下文限制的 <code>@rive-app/canvas</code>，或者考虑使用 <code>@rive-app/webgl2-advanced</code> 包，它允许您在同一个画布上绘制多个 Rive 图形。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>建议在创建 <code>new Rive({...})</code> 对象时，设置 <code>useOffscreenRenderer: true</code>。</p></div><p>有关 Rive 渲染器的更多信息，请参阅 <a href="/docs/runtimes/choose-a-renderer/">选择渲染器 (Choose a Renderer)</a> 章节。</p><h3 id="rive-app-webgl2-advanced" tabindex="-1">@rive-app/webgl2-advanced <a class="header-anchor" href="#rive-app-webgl2-advanced" aria-label="Permalink to &quot;@rive-app/webgl2-advanced&quot;">​</a></h3><div class="info custom-block"><p class="custom-block-title">INFO</p><p>这是使用 <a href="https://rive.app/renderer" target="_blank" rel="noreferrer">Rive 渲染器 (Rive Renderer)</a> 配合 WebGL2 上下文的预览版本。在未来的主版本发布中，此包可能会被弃用，届时 <code>@rive-app/webgl-advanced</code> 将完全使用 Rive 渲染器。</p></div><p>这是一个低级 Rive API，使用 WebGL2 上下文。它具备普通 <code>@rive-app/webgl2</code> 包的所有优点，外加：</p><ul><li>对更新和渲染循环的完全控制。</li><li>允许在同一个画布上渲染多个 Rive 图形。</li><li>使用新的 Rive 渲染器以获得最佳性能。</li><li>体积远小于现在的 <code>@rive-app/webgl-advanced</code>。</li><li>允许对 Rive 层级结构中的组件进行更深入的控制和操作。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>要利用 Rive 渲染器，您应该启用 draft 版的 <code>WEBGL_shader_pixel_local_storage</code> Chrome 扩展，否则在不支持该扩展的浏览器上将回退到 MSAA 方案。</p></div><p>此包是利用 Rive 渲染器性能的最佳方式，能够在一个画布上绘制大量的 Rive 图形。</p><h3 id="rive-app-canvas-advanced" tabindex="-1">@rive-app/canvas-advanced <a class="header-anchor" href="#rive-app-canvas-advanced" aria-label="Permalink to &quot;@rive-app/canvas-advanced&quot;">​</a></h3><p>这是一个低级 Rive API，使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">CanvasRenderingContext2D</a> 渲染器。它具备普通 <code>@rive-app/canvas</code> 包的所有优点，外加：</p><ul><li>对更新和渲染循环的完全控制。</li><li>允许在同一个画布上渲染多个 Rive 画板 (artboards)。</li><li>允许对 Rive 层级结构中的组件进行更深入的控制和操作。</li></ul><p>在此查看用法示例：<a href="#background">https://codesandbox.io/p/sandbox/canvas-advance-api-example-s6dz3m?file=%2Fsrc%2Findex.ts</a></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>想要一个 <strong>体积更小</strong> 且包含更少功能的 Rive 依赖？考虑使用下方的 <code>@rive-app/canvas-advanced-lite</code> 👇</p></div><h3 id="rive-app-canvas-advanced-lite" tabindex="-1">@rive-app/canvas-advanced-lite <a class="header-anchor" href="#rive-app-canvas-advanced-lite" aria-label="Permalink to &quot;@rive-app/canvas-advanced-lite&quot;">​</a></h3><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @rive-app/canvas-advanced-lite</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这是一个体积比 <code>@rive-app/canvas-advanced</code> 更小的包，具备相同的 API 和底层的 <code>CanvasRenderingContext2D</code>，但在构建 WASM 时剔除了一些依赖项以保持最小体积。</p><p>如果您不需要以下功能，此方案是首选：</p><ul><li><a href="/docs/editor/text/">Rive 文本 (Rive Text)</a></li></ul><h3 id="rive-app-webgl-advanced" tabindex="-1">@rive-app/webgl-advanced <a class="header-anchor" href="#rive-app-webgl-advanced" aria-label="Permalink to &quot;@rive-app/webgl-advanced&quot;">​</a></h3><p>这是一个低级 Rive API，使用 WebGL2 上下文。它具备普通 <code>@rive-app/webgl</code> 包的所有优点，外加：</p><ul><li>对更新和渲染循环的完全控制。</li><li>允许在同一个画布上渲染多个 Rive 图形。</li><li>允许对 Rive 层级结构中的组件进行更深入的控制和操作。</li></ul><h3 id="single-版本-single-versions" tabindex="-1">*-single 版本 (single versions) <a class="header-anchor" href="#single-版本-single-versions" aria-label="Permalink to &quot;*-single 版本 (single versions)&quot;">​</a></h3><p>上述每个 NPM 包都包含了 <code>rive.wasm</code> 文件。在高级 API（<code>@rive-app/canvas</code> 和 <code>@rive-app/webgl</code>）中，运行时会为您请求该文件，而 <code>-advanced</code> 版本则不然。我们还为上述每个包提供了 NPM 上的替代版本（不包括 <code>lite</code> 版本），这些版本直接在 JS 束中编码了 WASM。这意味着您不需要为驱动 Rive 动画的 WASM 发起网络请求，因为它全部包含在一个主 JS 文件中。如果您的应用在从 CDN 加载 WASM 时遇到问题，这是一个解决方案。</p><ul><li><a href="https://www.npmjs.com/package/@rive-app/canvas-single" target="_blank" rel="noreferrer">@rive-app/canvas-single</a></li><li><a href="https://www.npmjs.com/package/@rive-app/canvas-advanced-single" target="_blank" rel="noreferrer">@rive-app/canvas-advanced-single</a></li><li><a href="https://www.npmjs.com/package/@rive-app/webgl-single" target="_blank" rel="noreferrer">@rive-app/webgl-single</a></li><li><a href="https://www.npmjs.com/package/@rive-app/webgl-advanced-single" target="_blank" rel="noreferrer">@rive-app/webgl-advanced-single</a></li></ul><p>虽然此处不需要请求 WASM，但 JS 束会比上述包更大。非 single 版本在 Web 应用中可能有更好的缓存效果，因为如果从多个页面加载，WASM 会从同一个 CDN 源加载。</p>',51)])])}const h=a(r,[["render",n]]);export{b as __pageData,h as default};
