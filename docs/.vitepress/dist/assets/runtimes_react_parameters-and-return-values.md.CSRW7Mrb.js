import{_ as o,c,o as a,ag as d}from"./chunks/framework.WXS6e2PS.js";const p=JSON.parse('{"title":"参数和返回值 (Parameters and Return Values)","description":"Rive React API 详解。","frontmatter":{"title":"参数和返回值 (Parameters and Return Values)","description":"Rive React API 详解。"},"headers":[],"relativePath":"runtimes/react/parameters-and-return-values.md","filePath":"runtimes/react/parameters-and-return-values.md"}'),i={name:"runtimes/react/parameters-and-return-values.md"};function t(r,e,s,l,n,u){return a(),c("div",null,[...e[0]||(e[0]=[d('<h2 id="hook" tabindex="-1">Hook <a class="header-anchor" href="#hook" aria-label="Permalink to &quot;Hook&quot;">​</a></h2><h3 id="userive" tabindex="-1">useRive <a class="header-anchor" href="#userive" aria-label="Permalink to &quot;useRive&quot;">​</a></h3><p><code>useRive</code> hook 是推荐的接入 Rive 运行时的方案，能实现完全的控制，特别是在使用 Rive 状态机时。有关要传入的参数和返回值，请参见下文。</p><p><code>useRive(riveParams: UseRiveParameters, opts: UseRiveOptions): RiveState</code></p><ul><li><code>riveParams</code> - 参见下方，这是一组在实例化时从 Web 运行时传递给 <code>Rive</code> 对象的参数。可以传递 <code>null</code> 或 <code>undefined</code> 以有条件地显示 .riv 文件。</li><li><code>opts</code> - <em>(可选)</em> 参见下方，这是一组特定于 <code>rive-react</code> 的选项。</li></ul><h4 id="参数-parameters" tabindex="-1">参数 (Parameters) <a class="header-anchor" href="#参数-parameters" aria-label="Permalink to &quot;参数 (Parameters)&quot;">​</a></h4><p><strong>UseRiveParameters</strong></p><p>这些参数中的大部分来自 Rive 对象的底层 Web 运行时配置项，但提供 <code>canvas</code> 元素除外。有关您可以在此对象中提供的所有参数，请参阅 <a href="/docs/runtimes/web/rive-parameters">Rive 参数</a>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>如果您在参数中提供了 <code>onLoad</code> 回调，您可能还无法访问 <code>rive</code> 实例。React 运行时在内部使用 <code>onLoad</code> 通过 <code>rive</code> 实例执行 <code>setState</code>，因此在到达用户提供的回调时，实例可能尚未填充。如果您正在寻找类似的方法，我们建议使用 <code>useEffect</code> 代替 <code>onLoad</code> 以可靠地使用 <code>rive</code> 实例。在 Web 运行时的未来版本中，我们可能会在您的回调参数中提供 <code>rive</code> 实例，以便您在此处提供 <code>onLoad</code>。</p></div><p><strong>UseRiveOptions</strong></p><ul><li><code>useDevicePixelRatio</code> - <em>(可选)</em> 如果为 <code>true</code>，hook 将根据 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noreferrer">devicePixelRatio</a> 缩放动画分辨率。默认为 <code>true</code>。注意：需要将 <code>setContainerRef</code> ref 回调传递给包裹 canvas 元素的元素。如果您使用 <code>RiveComponent</code>，这将自动完成。</li><li><code>fitCanvasToArtboardHeight</code> - <em>(可选)</em> 如果为 <code>true</code>，画布将根据画板的高度调整大小。默认为 <code>false</code>。</li><li><code>useOffscreenRenderer</code> - <em>(可选)</em> 如果为 <code>true</code>，Rive 实例将共享（如果不存在则创建一个）离屏 <code>WebGL</code> 上下文。这允许您在一个屏幕上显示多个 Rive 动画，以规避某些浏览器关于多个并发 WebGL 上下文的限制。如果为 <code>false</code>，每个 Rive 实例将拥有自己的专用 <code>WebGL</code> 上下文，您可能需要注意刚才提到的浏览器限制。我们建议 <strong>不要</strong> 更改此默认属性，这样您就不必管理 WebGL 上下文。销毁 React 组件并不保证浏览器会清理挂载画布时创建的 WebGL 上下文。仅在使用 <code>@rive-app/react-webgl</code> 时相关。默认为 <code>true</code>。</li></ul><h4 id="返回值-return-values" tabindex="-1">返回值 (Return Values) <a class="header-anchor" href="#返回值-return-values" aria-label="Permalink to &quot;返回值 (Return Values)&quot;">​</a></h4><p><strong>RiveState</strong></p><ul><li><code>canvas</code> - 渲染 Rive 实例的画布 (Canvas) 元素。</li><li><code>container</code> - 渲染 Rive 实例的画布所在的容器元素。</li><li><code>setCanvasRef</code> - 传递给画布元素的 ref 回调。</li><li><code>setContainerRef</code> - 传递给画布容器元素的 ref 回调。这是可选的，但如果不使用，且在窗口缩放时，hook 将不会负责自动根据其外部容器调整画布大小。</li><li><code>rive</code> - 从 Web 运行时新创建的 Rive 实例。</li><li><code>RiveComponent</code> - 在 DOM 中渲染 Rive 实例的 JSX 元素。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在大多数情况下，您只需要从 <code>useRive</code> hook 中获取 <code>RiveComponent</code> 和 <code>rive</code> 返回值。只有在您需要自己控制画布/容器元素时，才需要设置画布 ref 和容器 ref。</p></div><h3 id="usestatemachineinput" tabindex="-1">useStateMachineInput <a class="header-anchor" href="#usestatemachineinput" aria-label="Permalink to &quot;useStateMachineInput&quot;">​</a></h3><p><code>useStateMachineInput</code> hook 是获取 Rive 状态机输入引用的推荐方式，既可以读取输入值，也可以设置（或触发）它们。有关要传入的参数和返回值，请参见下文。</p><p><code>useStateMachineInput(rive: Rive | null, stateMachineName?: string, inputName?: string, initialValue?: number | boolean): StateMachineInput | null</code></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>由于需要先解析 <code>rive</code> 实例，返回值（即状态机输入）可能不会立即生效。您可能需要使用 <code>useEffect</code> 来监测 <code>rive</code> 实例和 <code>useStateMachineInput</code> hook 的返回值何时生效。</p></div><h4 id="参数-parameters-1" tabindex="-1">参数 (Parameters) <a class="header-anchor" href="#参数-parameters-1" aria-label="Permalink to &quot;参数 (Parameters)&quot;">​</a></h4><ul><li><code>rive</code> - 第一个参数是实例化的 Rive 对象 —— 可以通过 <code>useRive</code> hook 检索。</li><li><code>stateMachineName?</code> - <em>(可选)</em> 要从中获取输入的状态机名称。</li><li><code>inputName?</code> - <em>(可选)</em> 要获取引用的单个状态机输入的名称。</li><li><code>initialValue?</code> - <em>(可选)</em> 要在输入上设置的初始值。</li></ul><h4 id="返回值-return-values-1" tabindex="-1">返回值 (Return Values) <a class="header-anchor" href="#返回值-return-values-1" aria-label="Permalink to &quot;返回值 (Return Values)&quot;">​</a></h4><p>此 hook 返回一个 <code>StateMachineInput</code> 的默认实例。</p><p><strong>StateMachineInput</strong></p><ul><li><code>name</code> (getter) - 访问输入的名称。</li><li><code>value</code> (getter 和 setter) - 访问输入的值，并通过此属性设置输入的值。</li><li><code>fire()</code> - 触发 trigger 类型的输入。</li></ul><p>有关此 hook 的更多用法，请参阅 <a href="/docs/runtimes/inputs">输入页面</a>。</p><h3 id="useresizecanvas" tabindex="-1">useResizeCanvas <a class="header-anchor" href="#useresizecanvas" aria-label="Permalink to &quot;useResizeCanvas&quot;">​</a></h3><p><code>useResizeCanvas</code> hook 是一个可选的工具 hook，用于将 <code>&lt;canvas&gt;</code> 元素的大小调整为其父容器元素的大小，同时重新设置画布适当的表面区域大小。当您不想使用 <code>useRive</code> hook 来渲染 Rive，且可能在 React 应用中使用 Web JS 运行时，但仍希望能够将 <code>&lt;canvas&gt;</code> 适当地缩放到其父级时，这非常有用。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>此 hook 已经在 Rive React 运行时内部使用，因此如果您使用 <code>useRive</code> hook 或默认导出的 <code>&lt;RiveComponent /&gt;</code> 来渲染 Rive，则不需要自己调用此 hook。</p></div><p><code>useResizeCanvas(resizeProps: UseResizeCanvasProps): void</code></p><ul><li><code>resizeProps</code> - 参见下方，要在该对象参数上设置的一组属性。</li></ul><h4 id="参数-parameters-2" tabindex="-1">参数 (Parameters) <a class="header-anchor" href="#参数-parameters-2" aria-label="Permalink to &quot;参数 (Parameters)&quot;">​</a></h4><p><strong>UseResizeCanvasProps</strong></p><ul><li><code>riveLoaded: boolean</code> - 如果为 <code>true</code>，则 Rive 实例已创建且 Rive 文件已解析。这确保了 hook 不会过早缩放 <code>&lt;canvas&gt;</code> 元素。默认为 <code>false</code>。</li><li><code>canvasRef: MutableRefObject&lt;HTMLCanvasElement | null&gt;</code> - Rive 渲染所在 <code>&lt;canvas&gt;</code> 元素的 React <code>Ref</code>。</li><li><code>containerRef: MutableRefObject&lt;HTMLElement | null&gt;</code> - 画布父容器元素的 React <code>Ref</code>。</li><li><code>onCanvasHasResized?: () =&gt; void</code> (可选) 画布因其父容器调整大小而调整大小后调用的回调。在此处，您可能想要重置 Rive 渲染器的布局维度，以指示画布的新最小/最大边界。 <ul><li>使用高级 JS 运行时，这可能只是对 <code>rive.resizeToCanvas()</code> 的简单调用。</li><li>使用低级 JS 运行时，这可能是调用渲染器的 <code>.align()</code> 方法，并传入布局以及画布的最小/最大 X/Y 值。</li></ul></li><li><code>options?: Partial</code> - (可选) 传递给 useRive hook 的选项（参见文档上方的 <code>UseRiveOptions</code>）。</li><li><code>artboardBounds?: Bounds</code> - (可选) 画板的 AABB 边界。只有在 <code>options.fitCanvasToArtboardHeight</code> 设置为 <code>true</code> 时，才需要提供此项。</li></ul><h3 id="userivefile" tabindex="-1">useRiveFile <a class="header-anchor" href="#userivefile" aria-label="Permalink to &quot;useRiveFile&quot;">​</a></h3><p><code>useRiveFile</code> hook 旨在用于在组件内初始化和管理 <code>RiveFile</code> 实例。它根据提供的源参数（URL 或 ArrayBuffer）设置 <code>RiveFile</code>，并确保在组件卸载或输入更改时正确清理，以避免内存泄漏。</p><p>此 hook 的主要优点是它允许您创建一个可以在多个组件中重复使用的 <code>RiveFile</code> 实例，而无需从 <code>src</code> URL 再次获取或从 <code>buffer</code> 重新加载。通过消除冗余的网络请求和加载时间，这提高了性能，特别是在从同一源创建多个 Rive 实例时。与直接向 <code>useRive</code> hook 传递 <code>buffer</code> 和 <code>src</code> 参数不同（后者在底层仍需要解析以创建 <code>RiveFile</code> 对象），此 hook 返回一个已经解析好的 <code>RiveFile</code> 对象，包含了所有已加载的资产。</p><p><code>useRiveFile(params: UseRiveFileParameters): RiveFileState</code></p><h4 id="参数-parameters-3" tabindex="-1">参数 (Parameters) <a class="header-anchor" href="#参数-parameters-3" aria-label="Permalink to &quot;参数 (Parameters)&quot;">​</a></h4><p><strong>UseRiveFileParameters</strong></p><ul><li><code>src?</code> - <em>(可选)</em> 使用 <code>src</code> 有两种可选方式：通过指向 <code>.riv</code> 文件的 URL，或者指向要使用的公共 <code>.riv</code> 资产的路径。必须提供 <code>src</code> 或 <code>buffer</code> 之一。 <ul><li>URL - 如果您将 <code>.riv</code> 托管在某些可公开访问的存储桶/CDN 上（例如 AWS、GCS 等），可以在此处传入 URL。 <ul><li>或者，使用 ES6，您可以将 <code>.riv</code> 文件作为 data URI 导入。根据您的 bundle 加载器，您可能需要使用插件（如 Webpack 的 <code>url-loader</code>）来正确解析并将 <code>.riv</code> 文件作为 data URI 字符串加载。参见<a href="https://github.com/zplata/rive-nextjs/blob/main/next.config.js#L8" target="_blank" rel="noreferrer">这个项目</a>作为一个基础设置示例。</li></ul></li><li>指向公共资产的路径 - 如果 <code>.riv</code> 公共资产捆绑在您的应用中，这是指向该资产的字符串路径。请注意，这 <strong>不是</strong> 相对于当前 JS 文件所在位置的相对路径。应将 <code>.riv</code> 视为应用中捆绑的任何其他资产，如图像或字体。如果您的 JS 在 Web 应用的根目录下编译运行，则必须指定从根目录到资产位置的路径。例如，如果您的资产位于 <code>/public/foo.riv</code>，而您的 JS 在根目录 <code>/</code> 运行，则应在此属性中指定：<code>src: &#39;/public/foo.riv&#39;</code>。</li></ul></li><li><code>buffer?</code> - <em>(可选)</em> 包含 .riv 文件原始字节的 ArrayBuffer。必须提供 <code>src</code> 或 <code>buffer</code> 之一。</li><li><code>enableRiveAssetCDN?</code> - <em>(可选)</em> 允许运行时自动加载托管在 Rive CDN 中的资产。默认启用。</li></ul><p><strong>返回值</strong></p><p><strong>RiveFileState</strong></p><ul><li><code>riveFile</code> - <code>RiveFile</code> 实例。在文件加载完成前为 <code>null</code>。</li><li><code>status</code> - 文件加载过程的状态，可以是 <code>idle</code> (空闲)、<code>loading</code> (正在加载)、<code>failed</code> (失败) 或 <code>success</code> (成功)。</li></ul><h2 id="组件-components" tabindex="-1">组件 (Components) <a class="header-anchor" href="#组件-components" aria-label="Permalink to &quot;组件 (Components)&quot;">​</a></h2><h3 id="rivecomponent" tabindex="-1"><code>&lt;RiveComponent /&gt;</code> <a class="header-anchor" href="#rivecomponent" aria-label="Permalink to &quot;`&lt;RiveComponent /&gt;`&quot;">​</a></h3><p>默认导出的 <code>RiveComponent</code> 和从 <code>useRive</code> hook 返回的 <code>RiveComponent</code> 都要在组件的 JSX 中进行渲染。如前所述，可以传递给 <code>canvas</code> 元素的所有属性和事件处理程序也可以传递给 <code>Rive</code> 组件，并以同样的方式使用。</p><p>需要注意的一点是，在组件上设置的 <code>style</code>/<code>className</code> prop 将传递给容器 <code>&lt;div&gt;</code> 元素，而不是底层的 <code>&lt;canvas&gt;</code> 本身。原因在于容器 <code>&lt;div&gt;</code> 元素为您处理了大小调整和布局，因此，所有样式都应传递给此元素。</p><p><code>&lt;canvas&gt;</code> 元素仍将接收传递给组件的所有其他 prop，例如 <code>aria-*</code> 属性、<code>role</code> 等。您还可以在组件内部设置子内容，作为无法显示 <code>&lt;canvas&gt;</code> 元素时的回退方案。</p>',49)])])}const m=o(i,[["render",t]]);export{p as __pageData,m as default};
