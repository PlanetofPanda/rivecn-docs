import{_ as e,c as r,o as a,ag as d}from"./chunks/framework.WXS6e2PS.js";const h=JSON.parse('{"title":"文件格式 (Format)","description":"","frontmatter":{"title":"文件格式 (Format)","description":""},"headers":[],"relativePath":"runtimes/advanced-topic/format.md","filePath":"runtimes/advanced-topic/format.md"}'),o={name:"runtimes/advanced-topic/format.md"};function i(p,t,n,c,l,b){return a(),r("div",null,[...t[0]||(t[0]=[d('<h2 id="运行时格式-runtime-format" tabindex="-1">运行时格式 (Runtime Format) <a class="header-anchor" href="#运行时格式-runtime-format" aria-label="Permalink to &quot;运行时格式 (Runtime Format)&quot;">​</a></h2><p>Rive 编辑器将您的项目导出为 <code>.riv</code> 文件，供 Rive 运行时使用。这是您的画板、图形、动画、状态机等的二进制表示。这是 Rive 的运行时读取该文件以在应用程序、游戏、网站等中显示您的内容。该格式旨在在快速加载、文件小以及未来更改/添加功能的灵活性之间提供平衡。</p><h3 id="二进制类型-binary-types" tabindex="-1">二进制类型 (Binary Types) <a class="header-anchor" href="#二进制类型-binary-types" aria-label="Permalink to &quot;二进制类型 (Binary Types)&quot;">​</a></h3><p>Rive 运行时文件的二进制读取器需要能够从流中读取这些数据类型。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>字节序为小端字节序 (Little Endian)。</p></div><table tabindex="0"><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>variable unsigned integer (可变无符号整数)</td><td>LEB128 可变编码的无符号整数（后续简称为 varuint）</td></tr><tr><td>unsigned integer (无符号整数)</td><td>4 字节无符号整数</td></tr><tr><td>string (字符串)</td><td>无符号整数，后跟提供长度的 utf-8 编码字节数组</td></tr><tr><td>float (浮点数)</td><td>以 4 字节 IEEE 754 编码的 32 位浮点数</td></tr></tbody></table><div class="info custom-block"><p class="custom-block-title">INFO</p><p>二进制读取器参考资料 <br><a href="https://github.com/rive-app/rive-flutter/blob/master/lib/src/utilities/binary_buffer/binary_reader.dart" target="_blank" rel="noreferrer">Dart</a> <a href="https://github.com/rive-app/rive-cpp/blob/master/src/core/binary_reader.cpp" target="_blank" rel="noreferrer">C++ 读取器</a> <a href="https://github.com/rive-app/rive-cpp/blob/master/include/core/reader.h" target="_blank" rel="noreferrer">C++ 解码器</a></p></div><h3 id="文件头-header" tabindex="-1">文件头 (Header) <a class="header-anchor" href="#文件头-header" aria-label="Permalink to &quot;文件头 (Header)&quot;">​</a></h3><p>文件头是写入文件的第一部分内容，为运行时提供基本信息以验证其是否能读取此文件。它提供了一个 ToC（目录/字段定义），允许运行时了解如何跳过它可能无法理解的属性和对象。这是该格式对未来编辑器更改/功能添加具有弹性的部分原因。旧版运行时至少可以尝试加载旧文件，并在不理解的对象和属性的情况下显示它。</p><table tabindex="0"><thead><tr><th>值</th><th>类型</th></tr></thead><tbody><tr><td>Fingerprint (指纹)</td><td>4 字节</td></tr><tr><td>Major Version (主版本号)</td><td>varuint</td></tr><tr><td>Minor Version (次版本号)</td><td>varuint</td></tr><tr><td>File ID (文件 ID)</td><td>varuint</td></tr><tr><td>ToC (目录)</td><td>字节对齐的位数组 (bit array)</td></tr></tbody></table><p><strong>指纹 (Fingerprint)</strong></p><p>文件指纹仅让导入器快速进行健全性检查，以确认它确实在查看由 Rive 导出的文件。这是代表 utf8/ascii &quot;RIVE&quot; 的 4 个字节。在十六进制编辑器中，它看起来像这样：</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>0x52 0x49 0x56 0x45 / &quot;RIVE&quot;</p></div><p><strong>主版本号 (Major Version)</strong></p><p>运行时仅与单一的主 Rive 导出格式版本兼容。当前的主格式版本是 7。如果版本 7 的运行时遇到版本 6 的文件，它将立即报错并停止读取后续内容，因为这被认为格式有根本性的不同。这是 Rive 在确有需要时从根本上更改其导出格式的最后手段。我们尽最大努力尽可能少地进行此类更改。我们最近需要从 6 升级到 7 以增加对状态机的支持，但在这样做时，我们将格式更改为对未来此类更改更具弹性。编辑器目前支持导出主版本 6 和主版本 7 文件，但使用主版本 6 导出的文件将不包含状态机支持。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>主版本之间不互通。主版本 6 的运行时无法读取主版本 7 的文件。同样，主版本 7 的文件也无法由主版本 6 的运行时读取。</p></div><p><strong>次版本号 (Minor Version)</strong></p><p>只要主版本号相同，次版本号的更改就是相互兼容的。但是，如果运行时的次版本号不同，某些较新的功能可能无法使用。例如，主版本 7 引入了状态机。我们正在努力为状态机添加新的状态类型。7.0 版本的运行时可能无法加载 7.1 文件中导出的所有状态。但是，该运行时仍然能够播放该状态机，只是在过渡到它无法理解的状态时无法执行任何操作。</p><p>版本兼容性示例：</p><table tabindex="0"><thead><tr><th>运行时版本</th><th>文件版本</th><th>兼容性</th></tr></thead><tbody><tr><td>6.1</td><td>6.0</td><td>是</td></tr><tr><td>6.1</td><td>6.2</td><td>是</td></tr><tr><td>6.1</td><td>7.0</td><td>否</td></tr><tr><td>7.0</td><td>6.1</td><td>否</td></tr><tr><td>7.0</td><td>7.1</td><td>是</td></tr></tbody></table><p><strong>文件 ID (File ID)</strong></p><p>这是文件的唯一标识符，将来可用于通过我们的 API 区分文件。API 尚未定义，但计划中的一些功能包括按需重新导出更新版本的文件、获取文件详细信息等。目前，这可用于验证导出是从哪个文件生成的。</p><p><strong>目录 (ToC)</strong></p><p>文件头中的目录 (Table of Contents) 部分是文件中属性及其后台类型的列表。这允许运行时读过它希望跳过或无法理解的属性。它通过为每个属性 ID 提供后台类型来实现这一点。</p><p><strong>字段类型 (Field Types)</strong></p><p>有 5 种基本的后台类型，但它们以 4 种不同的方式序列化。了解类型的序列化方式允许运行时知道如何读取它。即使读取的值错误或解释不当，关键在于能够跳过它，以便安全地读取文件的其余部分。</p><p>例如，布尔值可以作为后台类型和序列化器兼容的无符号整数读取。即使将布尔值读取为整数无法提供该属性的有效值，运行时仍然可以将其跳过。</p><p><strong>目录数据 (ToC Data)</strong></p><p>已知属性列表被序列化为一系列以 0 终止的可变无符号整数。有效的属性键由非零无符号整数 ID/键标识。属性后面是一个位数组，由已读属性计数 / 4 字节组成。每个属性分配 2 位来定义可以使用哪种后台类型反序列化器来跳过它。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>此处的目的是提供已知属性类型的键及其后台类型，这样如果属性类型未知，读取器就可以在不引起缓冲区欠载/溢出的情况下读取值的全部内容。</p></div><table tabindex="0"><thead><tr><th>后台类型</th><th>2 位值</th></tr></thead><tbody><tr><td>Uint/Bool</td><td>0</td></tr><tr><td>String</td><td>1</td></tr><tr><td>Float</td><td>2</td></tr><tr><td>Color</td><td>3</td></tr></tbody></table><p>举个例子，如果一个文件有三个已知属性类型（属性 12 为 uint 值，属性 16 为 string 值，属性 6 为 bool 值），导出器将按如下方式序列化数据：</p><p>varuint: 12</p><p>varuint: 16</p><p>varuint: 6</p><p>varuint: 0</p><p>2 位: 0</p><p>2 位: 1</p><p>2 位: 0</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>参考 ToC 反序列化器：<a href="https://github.com/rive-app/rive-flutter/blob/bbee63bb6c791dcabd0cd9d9788ca7ec4783fddb/lib/src/rive_core/runtime/runtime_header.dart#L43-L60" target="_blank" rel="noreferrer">Flutter</a> <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/include/runtime_header.hpp#L76-L104" target="_blank" rel="noreferrer">C++</a></p></div><p><strong>底线属性 (Baseline properties)</strong></p><p>Rive 不会导出自最新主版本以来系统已知的属性。当切换新的主版本时，我们会建立底线，因为不存在需要读过较新属性的次版本。在切换到最新主版本后引入的新属性将在添加新属性并发布新次版本时导出。</p><h2 id="内容-content" tabindex="-1">内容 (Content) <a class="header-anchor" href="#内容-content" aria-label="Permalink to &quot;内容 (Content)&quot;">​</a></h2><p>文件的其余部分只是一个对象列表，每个对象都包含其属性和值的列表。对象由 varuint 类型的键表示。它后面紧跟着属性列表。属性以 0 varuint 终止。如果读取到非 0 值，则预期它是该属性的类型键。如果运行时知道该类型键，它将知道后台类型以及如何对其解码。类型键后面跟随的字节将是前面指定的二进制类型之一。如果它是未知的，它可以根据 ToC 确定后台类型是什么并跳过它。</p><h3 id="核心-core" tabindex="-1">核心 (Core) <a class="header-anchor" href="#核心-core" aria-label="Permalink to &quot;核心 (Core)&quot;">​</a></h3><p>所有对象和属性都定义在的一组文件中，我们称之为 <a href="https://github.com/rive-app/rive-cpp/tree/master/dev/defs" target="_blank" rel="noreferrer">核心定义 (Core Definitions)</a>。它们被定义在一系列 JSON 对象中，帮助 Rive 生成序列化、反序列化和动画属性代码。C++ 和 Flutter 运行时都有辅助程序来读取并生成这些类型的大量样板代码。</p><p><strong>对象 (Object)</strong></p><p>一个核心对象由其 Core 类型键表示。例如，Shape 的 <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/dev/defs/shapes/shape.json#L4" target="_blank" rel="noreferrer">核心类型键为 3</a>。类似地，您可以看到为 C++ 运行时生成的代码也 <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/include/generated/shapes/shape_base.hpp#L12" target="_blank" rel="noreferrer">使用相同的键标识 Shape</a>。</p><p><strong>属性 (Properties)</strong></p><p>属性同样由 Core 类型键表示。这些在所有对象中都是唯一的，因此 <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/dev/defs/node.json#L16" target="_blank" rel="noreferrer">属性键 13</a> 始终是 Node 对象的 X 值，并且 <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/include/generated/node_base.hpp#L33" target="_blank" rel="noreferrer">在运行时中匹配</a>。已知 Node 的 X 值是一个浮点值，因此当遇到它时，<a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/include/generated/node_base.hpp#L66-L68" target="_blank" rel="noreferrer">它将按原样解码</a>。属性键 0 被保留为 null 终止符（意味着我们已完成读取当前对象的属性）。</p><h3 id="序列化对象示例-example-serialized-object" tabindex="-1">序列化对象示例 (Example Serialized Object) <a class="header-anchor" href="#序列化对象示例-example-serialized-object" aria-label="Permalink to &quot;序列化对象示例 (Example Serialized Object)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>数据</th><th>类型/大小</th><th>描述</th></tr></thead><tbody><tr><td>2</td><td>varuint</td><td>类型为 2 的对象 (Node)</td></tr><tr><td>13</td><td>varuint</td><td>Node 的 X 属性</td></tr><tr><td>100.0</td><td>4 字节浮点数</td><td>Node 的 X 值</td></tr><tr><td>14</td><td>varuint</td><td>Node 的 Y 属性</td></tr><tr><td>22.0</td><td>4 字节浮点数</td><td>Node 的 Y 值</td></tr><tr><td>0</td><td>varuint</td><td>Null 终止符。属性读取完毕，Node 读取完成。</td></tr></tbody></table><h3 id="上下文-context" tabindex="-1">上下文 (Context) <a class="header-anchor" href="#上下文-context" aria-label="Permalink to &quot;上下文 (Context)&quot;">​</a></h3><p>对象总是在相互关联的背景下提供的。Shape 总是会在 Artboard 之后提供。Node 的画板总是可以通过查找最近读取的 Artboard 来确定。这一概念被广泛用于为需要上下文的对象提供背景。另一个例子是，KeyFrame 总是会在 LinearAnimation 之后提供，这意味着您总是可以通过简单地跟踪最后读取的 LinearAnimation 来确定 KeyFrame 属于哪个 LinearAnimation。</p><h3 id="层次结构-hierarchy" tabindex="-1">层次结构 (Hierarchy) <a class="header-anchor" href="#层次结构-hierarchy" aria-label="Permalink to &quot;层次结构 (Hierarchy)&quot;">​</a></h3><p>画板内部的对象可以父级化到画板中的其他对象。这种映射更为复杂，需要标识符来查找父级。这些标识符作为 <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/dev/defs/component.json#L28-L38" target="_blank" rel="noreferrer">core def 属性</a> 提供。该值始终是一个无符号整数，代表在画板内部使 ContainerComponent 派生对象成为有效父级的索引。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>有关导入上下文的详细信息，您可以查看文件读取器中使用的 ImportStack 模式。<a href="https://github.com/rive-app/rive-flutter/blob/bbee63bb6c791dcabd0cd9d9788ca7ec4783fddb/lib/src/rive_file.dart#L101" target="_blank" rel="noreferrer">Dart</a> <a href="https://github.com/rive-app/rive-cpp/blob/4512406300b7333ba543cd87930e67a24c2fc715/src/file.cpp#L137" target="_blank" rel="noreferrer">C++</a></p></div>',57)])])}const u=e(o,[["render",i]]);export{h as __pageData,u as default};
